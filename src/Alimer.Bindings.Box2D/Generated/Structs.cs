// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;

#pragma warning disable CS0649
public partial struct b2Version
{
	public int major;
	public int minor;
	public int revision;
}

public partial struct b2CosSin
{
	public float cosine;
	public float sine;
}

public partial struct b2Rot
{
	public float c;
	public float s;
}

public partial struct b2Transform
{
	public System.Numerics.Vector2 p;
	public b2Rot q;
}

public partial struct b2Mat22
{
	public System.Numerics.Vector2 cx;
	public System.Numerics.Vector2 cy;
}

public partial struct b2AABB
{
	public System.Numerics.Vector2 lowerBound;
	public System.Numerics.Vector2 upperBound;
}

public partial struct b2Plane
{
	public System.Numerics.Vector2 normal;
	public float offset;
}

public partial struct b2SimplexCache
{
	public ushort count;
	public unsafe fixed byte indexA[3];
	public unsafe fixed byte indexB[3];
}

public partial struct b2Hull
{
	public points__FixedBuffer points;

	public unsafe struct points__FixedBuffer
	{
		public System.Numerics.Vector2 e0;
		public System.Numerics.Vector2 e1;
		public System.Numerics.Vector2 e2;
		public System.Numerics.Vector2 e3;
		public System.Numerics.Vector2 e4;
		public System.Numerics.Vector2 e5;
		public System.Numerics.Vector2 e6;
		public System.Numerics.Vector2 e7;

		[UnscopedRef]
		public ref System.Numerics.Vector2 this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref AsSpan()[index];
			}
		}

		[UnscopedRef]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<System.Numerics.Vector2> AsSpan()
		{
			return MemoryMarshal.CreateSpan(ref e0, 8);
		}
	}
	public int count;
}

public partial struct b2RayCastInput
{
	public System.Numerics.Vector2 origin;
	public System.Numerics.Vector2 translation;
	public float maxFraction;
}

public partial struct b2ShapeProxy
{
	public points__FixedBuffer points;

	public unsafe struct points__FixedBuffer
	{
		public System.Numerics.Vector2 e0;
		public System.Numerics.Vector2 e1;
		public System.Numerics.Vector2 e2;
		public System.Numerics.Vector2 e3;
		public System.Numerics.Vector2 e4;
		public System.Numerics.Vector2 e5;
		public System.Numerics.Vector2 e6;
		public System.Numerics.Vector2 e7;

		[UnscopedRef]
		public ref System.Numerics.Vector2 this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref AsSpan()[index];
			}
		}

		[UnscopedRef]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<System.Numerics.Vector2> AsSpan()
		{
			return MemoryMarshal.CreateSpan(ref e0, 8);
		}
	}
	public int count;
	public float radius;
}

public partial struct b2ShapeCastInput
{
	public b2ShapeProxy proxy;
	public System.Numerics.Vector2 translation;
	public float maxFraction;
	public bool canEncroach;
}

public partial struct b2CastOutput
{
	public System.Numerics.Vector2 normal;
	public System.Numerics.Vector2 point;
	public float fraction;
	public int iterations;
	public bool hit;
}

public partial struct b2MassData
{
	public float mass;
	public System.Numerics.Vector2 center;
	public float rotationalInertia;
}

public partial struct b2Circle
{
	public System.Numerics.Vector2 center;
	public float radius;
}

public partial struct b2Capsule
{
	public System.Numerics.Vector2 center1;
	public System.Numerics.Vector2 center2;
	public float radius;
}

public partial struct b2Polygon
{
	public vertices__FixedBuffer vertices;

	public unsafe struct vertices__FixedBuffer
	{
		public System.Numerics.Vector2 e0;
		public System.Numerics.Vector2 e1;
		public System.Numerics.Vector2 e2;
		public System.Numerics.Vector2 e3;
		public System.Numerics.Vector2 e4;
		public System.Numerics.Vector2 e5;
		public System.Numerics.Vector2 e6;
		public System.Numerics.Vector2 e7;

		[UnscopedRef]
		public ref System.Numerics.Vector2 this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref AsSpan()[index];
			}
		}

		[UnscopedRef]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<System.Numerics.Vector2> AsSpan()
		{
			return MemoryMarshal.CreateSpan(ref e0, 8);
		}
	}
	public normals__FixedBuffer normals;

	public unsafe struct normals__FixedBuffer
	{
		public System.Numerics.Vector2 e0;
		public System.Numerics.Vector2 e1;
		public System.Numerics.Vector2 e2;
		public System.Numerics.Vector2 e3;
		public System.Numerics.Vector2 e4;
		public System.Numerics.Vector2 e5;
		public System.Numerics.Vector2 e6;
		public System.Numerics.Vector2 e7;

		[UnscopedRef]
		public ref System.Numerics.Vector2 this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref AsSpan()[index];
			}
		}

		[UnscopedRef]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<System.Numerics.Vector2> AsSpan()
		{
			return MemoryMarshal.CreateSpan(ref e0, 8);
		}
	}
	public System.Numerics.Vector2 centroid;
	public float radius;
	public int count;
}

public partial struct b2Segment
{
	public System.Numerics.Vector2 point1;
	public System.Numerics.Vector2 point2;
}

public partial struct b2ChainSegment
{
	public System.Numerics.Vector2 ghost1;
	public b2Segment segment;
	public System.Numerics.Vector2 ghost2;
	public int chainId;
}

public partial struct b2SegmentDistanceResult
{
	public System.Numerics.Vector2 closest1;
	public System.Numerics.Vector2 closest2;
	public float fraction1;
	public float fraction2;
	public float distanceSquared;
}

public partial struct b2DistanceInput
{
	public b2ShapeProxy proxyA;
	public b2ShapeProxy proxyB;
	public b2Transform transformA;
	public b2Transform transformB;
	public bool useRadii;
}

public partial struct b2DistanceOutput
{
	public System.Numerics.Vector2 pointA;
	public System.Numerics.Vector2 pointB;
	public System.Numerics.Vector2 normal;
	public float distance;
	public int iterations;
	public int simplexCount;
}

public partial struct b2SimplexVertex
{
	public System.Numerics.Vector2 wA;
	public System.Numerics.Vector2 wB;
	public System.Numerics.Vector2 w;
	public float a;
	public int indexA;
	public int indexB;
}

public partial struct b2Simplex
{
	public b2SimplexVertex v1;
	public b2SimplexVertex v2;
	public b2SimplexVertex v3;
	public int count;
}

public partial struct b2ShapeCastPairInput
{
	public b2ShapeProxy proxyA;
	public b2ShapeProxy proxyB;
	public b2Transform transformA;
	public b2Transform transformB;
	public System.Numerics.Vector2 translationB;
	public float maxFraction;
	public bool canEncroach;
}

public partial struct b2Sweep
{
	public System.Numerics.Vector2 localCenter;
	public System.Numerics.Vector2 c1;
	public System.Numerics.Vector2 c2;
	public b2Rot q1;
	public b2Rot q2;
}

public partial struct b2TOIInput
{
	public b2ShapeProxy proxyA;
	public b2ShapeProxy proxyB;
	public b2Sweep sweepA;
	public b2Sweep sweepB;
	public float maxFraction;
}

public partial struct b2TOIOutput
{
	public b2TOIState state;
	public System.Numerics.Vector2 point;
	public System.Numerics.Vector2 normal;
	public float fraction;
}

public partial struct b2ManifoldPoint
{
	public System.Numerics.Vector2 point;
	public System.Numerics.Vector2 anchorA;
	public System.Numerics.Vector2 anchorB;
	public float separation;
	public float normalImpulse;
	public float tangentImpulse;
	public float totalNormalImpulse;
	public float normalVelocity;
	public ushort id;
	public bool persisted;
}

public partial struct b2Manifold
{
	public System.Numerics.Vector2 normal;
	public float rollingImpulse;
	public points__FixedBuffer points;

	public unsafe struct points__FixedBuffer
	{
		public b2ManifoldPoint e0;
		public b2ManifoldPoint e1;

		[UnscopedRef]
		public ref b2ManifoldPoint this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref AsSpan()[index];
			}
		}

		[UnscopedRef]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<b2ManifoldPoint> AsSpan()
		{
			return MemoryMarshal.CreateSpan(ref e0, 2);
		}
	}
	public int pointCount;
}

public partial struct b2DynamicTree
{
	public nint nodes;
	public int root;
	public int nodeCount;
	public int nodeCapacity;
	public int freeList;
	public int proxyCount;
	public unsafe int* leafIndices;
	public unsafe b2AABB* leafBoxes;
	public unsafe System.Numerics.Vector2* leafCenters;
	public unsafe int* binIndices;
	public int rebuildCapacity;
}

public partial struct b2TreeStats
{
	public int nodeVisits;
	public int leafVisits;
}

public partial struct b2PlaneResult
{
	public b2Plane plane;
	public System.Numerics.Vector2 point;
	public bool hit;
}

public partial struct b2CollisionPlane
{
	public b2Plane plane;
	public float pushLimit;
	public float push;
	public bool clipVelocity;
}

public partial struct b2PlaneSolverResult
{
	public System.Numerics.Vector2 translation;
	public int iterationCount;
}

public partial struct b2WorldId
{
	public ushort index1;
	public ushort generation;
}

public partial struct b2BodyId
{
	public int index1;
	public ushort world0;
	public ushort generation;
}

public partial struct b2ShapeId
{
	public int index1;
	public ushort world0;
	public ushort generation;
}

public partial struct b2ChainId
{
	public int index1;
	public ushort world0;
	public ushort generation;
}

public partial struct b2JointId
{
	public int index1;
	public ushort world0;
	public ushort generation;
}

public partial struct b2ContactId
{
	public int index1;
	public ushort world0;
	public short padding;
	public uint generation;
}

public partial struct b2RayResult
{
	public b2ShapeId shapeId;
	public System.Numerics.Vector2 point;
	public System.Numerics.Vector2 normal;
	public float fraction;
	public int nodeVisits;
	public int leafVisits;
	public bool hit;
}

public partial struct b2WorldDef
{
	public System.Numerics.Vector2 gravity;
	public float restitutionThreshold;
	public float hitEventThreshold;
	public float contactHertz;
	public float contactDampingRatio;
	public float contactSpeed;
	public float maximumLinearSpeed;
	public unsafe delegate* unmanaged<float, ulong, float, ulong, float> frictionCallback;
	public unsafe delegate* unmanaged<float, ulong, float, ulong, float> restitutionCallback;
	public bool enableSleep;
	public bool enableContinuous;
	public bool enableContactSoftening;
	public int workerCount;
	public unsafe delegate* unmanaged<delegate* unmanaged<int, int, uint, void*, void>, int, int, void*, void*, void*> enqueueTask;
	public unsafe delegate* unmanaged<void*, void*, void> finishTask;
	public unsafe void* userTaskContext;
	public unsafe void* userData;
	public int internalValue;
}

public partial struct b2MotionLocks
{
	public bool linearX;
	public bool linearY;
	public bool angularZ;
}

public partial struct b2BodyDef
{
	public b2BodyType type;
	public System.Numerics.Vector2 position;
	public b2Rot rotation;
	public System.Numerics.Vector2 linearVelocity;
	public float angularVelocity;
	public float linearDamping;
	public float angularDamping;
	public float gravityScale;
	public float sleepThreshold;
	public unsafe byte* name;
	public unsafe void* userData;
	public b2MotionLocks motionLocks;
	public bool enableSleep;
	public bool isAwake;
	public bool isBullet;
	public bool isEnabled;
	public bool allowFastRotation;
	public int internalValue;
}

public partial struct b2Filter
{
	public ulong categoryBits;
	public ulong maskBits;
	public int groupIndex;
}

public partial struct b2QueryFilter
{
	public ulong categoryBits;
	public ulong maskBits;
}

public partial struct b2SurfaceMaterial
{
	public float friction;
	public float restitution;
	public float rollingResistance;
	public float tangentSpeed;
	public ulong userMaterialId;
	public uint customColor;
}

public partial struct b2ShapeDef
{
	public unsafe void* userData;
	public b2SurfaceMaterial material;
	public float density;
	public b2Filter filter;
	public bool enableCustomFiltering;
	public bool isSensor;
	public bool enableSensorEvents;
	public bool enableContactEvents;
	public bool enableHitEvents;
	public bool enablePreSolveEvents;
	public bool invokeContactCreation;
	public bool updateBodyMass;
	public int internalValue;
}

public partial struct b2ChainDef
{
	public unsafe void* userData;
	public unsafe System.Numerics.Vector2* points;
	public int count;
	public unsafe b2SurfaceMaterial* materials;
	public int materialCount;
	public b2Filter filter;
	public bool isLoop;
	public bool enableSensorEvents;
	public int internalValue;
}

public partial struct b2Profile
{
	public float step;
	public float pairs;
	public float collide;
	public float solve;
	public float prepareStages;
	public float solveConstraints;
	public float prepareConstraints;
	public float integrateVelocities;
	public float warmStart;
	public float solveImpulses;
	public float integratePositions;
	public float relaxImpulses;
	public float applyRestitution;
	public float storeImpulses;
	public float splitIslands;
	public float transforms;
	public float sensorHits;
	public float jointEvents;
	public float hitEvents;
	public float refit;
	public float bullets;
	public float sleepIslands;
	public float sensors;
}

public partial struct b2Counters
{
	public int bodyCount;
	public int shapeCount;
	public int contactCount;
	public int jointCount;
	public int islandCount;
	public int stackUsed;
	public int staticTreeHeight;
	public int treeHeight;
	public int byteCount;
	public int taskCount;
	public unsafe fixed int colorCounts[24];
}

public partial struct b2JointDef
{
	public unsafe void* userData;
	public b2BodyId bodyIdA;
	public b2BodyId bodyIdB;
	public b2Transform localFrameA;
	public b2Transform localFrameB;
	public float forceThreshold;
	public float torqueThreshold;
	public float constraintHertz;
	public float constraintDampingRatio;
	public float drawScale;
	public bool collideConnected;
}

public partial struct b2DistanceJointDef
{
	public b2JointDef @base;
	public float length;
	public bool enableSpring;
	public float lowerSpringForce;
	public float upperSpringForce;
	public float hertz;
	public float dampingRatio;
	public bool enableLimit;
	public float minLength;
	public float maxLength;
	public bool enableMotor;
	public float maxMotorForce;
	public float motorSpeed;
	public int internalValue;
}

public partial struct b2MotorJointDef
{
	public b2JointDef @base;
	public System.Numerics.Vector2 linearVelocity;
	public float maxVelocityForce;
	public float angularVelocity;
	public float maxVelocityTorque;
	public float linearHertz;
	public float linearDampingRatio;
	public float maxSpringForce;
	public float angularHertz;
	public float angularDampingRatio;
	public float maxSpringTorque;
	public int internalValue;
}

public partial struct b2FilterJointDef
{
	public b2JointDef @base;
	public int internalValue;
}

public partial struct b2PrismaticJointDef
{
	public b2JointDef @base;
	public bool enableSpring;
	public float hertz;
	public float dampingRatio;
	public float targetTranslation;
	public bool enableLimit;
	public float lowerTranslation;
	public float upperTranslation;
	public bool enableMotor;
	public float maxMotorForce;
	public float motorSpeed;
	public int internalValue;
}

public partial struct b2RevoluteJointDef
{
	public b2JointDef @base;
	public float targetAngle;
	public bool enableSpring;
	public float hertz;
	public float dampingRatio;
	public bool enableLimit;
	public float lowerAngle;
	public float upperAngle;
	public bool enableMotor;
	public float maxMotorTorque;
	public float motorSpeed;
	public int internalValue;
}

public partial struct b2WeldJointDef
{
	public b2JointDef @base;
	public float linearHertz;
	public float angularHertz;
	public float linearDampingRatio;
	public float angularDampingRatio;
	public int internalValue;
}

public partial struct b2WheelJointDef
{
	public b2JointDef @base;
	public bool enableSpring;
	public float hertz;
	public float dampingRatio;
	public bool enableLimit;
	public float lowerTranslation;
	public float upperTranslation;
	public bool enableMotor;
	public float maxMotorTorque;
	public float motorSpeed;
	public int internalValue;
}

public partial struct b2ExplosionDef
{
	public ulong maskBits;
	public System.Numerics.Vector2 position;
	public float radius;
	public float falloff;
	public float impulsePerLength;
}

public partial struct b2SensorBeginTouchEvent
{
	public b2ShapeId sensorShapeId;
	public b2ShapeId visitorShapeId;
}

public partial struct b2SensorEndTouchEvent
{
	public b2ShapeId sensorShapeId;
	public b2ShapeId visitorShapeId;
}

public partial struct b2SensorEvents
{
	public unsafe b2SensorBeginTouchEvent* beginEvents;
	public unsafe b2SensorEndTouchEvent* endEvents;
	public int beginCount;
	public int endCount;
}

public partial struct b2ContactBeginTouchEvent
{
	public b2ShapeId shapeIdA;
	public b2ShapeId shapeIdB;
	public b2ContactId contactId;
}

public partial struct b2ContactEndTouchEvent
{
	public b2ShapeId shapeIdA;
	public b2ShapeId shapeIdB;
	public b2ContactId contactId;
}

public partial struct b2ContactHitEvent
{
	public b2ShapeId shapeIdA;
	public b2ShapeId shapeIdB;
	public b2ContactId contactId;
	public System.Numerics.Vector2 point;
	public System.Numerics.Vector2 normal;
	public float approachSpeed;
}

public partial struct b2ContactEvents
{
	public unsafe b2ContactBeginTouchEvent* beginEvents;
	public unsafe b2ContactEndTouchEvent* endEvents;
	public unsafe b2ContactHitEvent* hitEvents;
	public int beginCount;
	public int endCount;
	public int hitCount;
}

public partial struct b2BodyMoveEvent
{
	public unsafe void* userData;
	public b2Transform transform;
	public b2BodyId bodyId;
	public bool fellAsleep;
}

public partial struct b2BodyEvents
{
	public unsafe b2BodyMoveEvent* moveEvents;
	public int moveCount;
}

public partial struct b2JointEvent
{
	public b2JointId jointId;
	public unsafe void* userData;
}

public partial struct b2JointEvents
{
	public unsafe b2JointEvent* jointEvents;
	public int count;
}

public partial struct b2ContactData
{
	public b2ContactId contactId;
	public b2ShapeId shapeIdA;
	public b2ShapeId shapeIdB;
	public b2Manifold manifold;
}

public partial struct b2DebugDraw
{
	public unsafe delegate* unmanaged<System.Numerics.Vector2*, int, b2HexColor, void*, void> DrawPolygonFcn;
	public unsafe delegate* unmanaged<b2Transform, System.Numerics.Vector2*, int, float, b2HexColor, void*, void> DrawSolidPolygonFcn;
	public unsafe delegate* unmanaged<System.Numerics.Vector2, float, b2HexColor, void*, void> DrawCircleFcn;
	public unsafe delegate* unmanaged<b2Transform, float, b2HexColor, void*, void> DrawSolidCircleFcn;
	public unsafe delegate* unmanaged<System.Numerics.Vector2, System.Numerics.Vector2, float, b2HexColor, void*, void> DrawSolidCapsuleFcn;
	public unsafe delegate* unmanaged<System.Numerics.Vector2, System.Numerics.Vector2, b2HexColor, void*, void> DrawLineFcn;
	public unsafe delegate* unmanaged<b2Transform, void*, void> DrawTransformFcn;
	public unsafe delegate* unmanaged<System.Numerics.Vector2, float, b2HexColor, void*, void> DrawPointFcn;
	public unsafe delegate* unmanaged<System.Numerics.Vector2, byte*, b2HexColor, void*, void> DrawStringFcn;
	public b2AABB drawingBounds;
	public float forceScale;
	public float jointScale;
	public bool drawShapes;
	public bool drawJoints;
	public bool drawJointExtras;
	public bool drawBounds;
	public bool drawMass;
	public bool drawBodyNames;
	public bool drawContactPoints;
	public bool drawGraphColors;
	public bool drawContactFeatures;
	public bool drawContactNormals;
	public bool drawContactForces;
	public bool drawFrictionForces;
	public bool drawIslands;
	public unsafe void* context;
}

